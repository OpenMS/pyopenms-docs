

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Wrapping Workflow and wrapping new Classes &mdash; pyOpenMS 2.5.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Build from source" href="build_from_source.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pyOpenMS
          

          
          </a>

          
            
            
              <div class="version">
                2.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">pyOpenMS Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">First steps</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_handling.html">Reading Raw MS data</a></li>
<li class="toctree-l1"><a class="reference internal" href="mzMLFileFormat.html">mzML files</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_file_handling.html">Other MS data formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Mass Spectrometry Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="datastructures.html">MS Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="chemistry.html">Chemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="aasequences.html">Peptides and Proteins</a></li>
<li class="toctree-l1"><a class="reference internal" href="nasequences.html">Oligonucleotides: RNA</a></li>
<li class="toctree-l1"><a class="reference internal" href="theoreticalspectrumgenerator.html">TheoreticalSpectrumGenerator</a></li>
<li class="toctree-l1"><a class="reference internal" href="digestion.html">Digestion</a></li>
<li class="toctree-l1"><a class="reference internal" href="datastructures_id.html">Identification Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="datastructures_quant.html">Quantitative Data</a></li>
</ul>
<p class="caption"><span class="caption-text">Simple Data Manipulation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="data_manipulation.html">Simple Data Manipulation</a></li>
</ul>
<p class="caption"><span class="caption-text">OpenMS Algorithms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="parameter_handling.html">Parameter Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="smoothing.html">Smoothing</a></li>
<li class="toctree-l1"><a class="reference internal" href="mass_decomposition.html">Mass Decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="deisotoping.html">Charge and Isotope Deconvolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="feature_detection.html">Feature Detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="peptide_search.html">Peptide Search</a></li>
<li class="toctree-l1"><a class="reference internal" href="chromatographic_analysis.html">Chromagraphic Analysis</a></li>
</ul>
<p class="caption"><span class="caption-text">R language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyopenms_in_r.html">pyOpenMS in R</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="build_from_source.html">Build from source</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Wrapping Workflow and wrapping new Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#how-pyopenms-wraps-python-classes">How pyOpenMS wraps Python classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-wrap-new-methods-in-existing-classes">How to wrap new methods in existing classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-wrap-new-classes">How to wrap new classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-simple-example">A simple example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-further-example">A further example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#an-example-with-handwritten-addon-code">An example with handwritten addon code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#considerations-and-limitations">Considerations and limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wrapping-code-yourself-in-addons">Wrapping code yourself in ./addons</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyOpenMS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Wrapping Workflow and wrapping new Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/wrap_classes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="wrapping-workflow-and-wrapping-new-classes">
<h1>Wrapping Workflow and wrapping new Classes<a class="headerlink" href="#wrapping-workflow-and-wrapping-new-classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="how-pyopenms-wraps-python-classes">
<h2>How pyOpenMS wraps Python classes<a class="headerlink" href="#how-pyopenms-wraps-python-classes" title="Permalink to this headline">¶</a></h2>
<p>General concept of how the wrapping is done (all files are in <code class="docutils literal notranslate"><span class="pre">src/pyOpenMS/</span></code>):</p>
<ul class="simple">
<li>Step 1: The author declares which classes and which functions of these
classes s/he wants to wrap (expose to Python). This is done by writing the
function declaration in a file in the <code class="docutils literal notranslate"><span class="pre">pxds/</span></code> folder.</li>
<li>Step 2: The Python tool “autowrap” (developed for this project) creates the
wrapping code automatically from the function declaration - see
<a class="reference external" href="https://github.com/uweschmitt/autowrap">https://github.com/uweschmitt/autowrap</a> for an explanation of the autowrap
tool.
Since not all code can be wrapped automatically, also manual code can be
written in the <code class="docutils literal notranslate"><span class="pre">addons/</span></code> folder. Autowrap will create an output file at
<code class="docutils literal notranslate"><span class="pre">pyopenms/pyopenms.pyx</span></code> which can be interpreted by Cython.</li>
<li>Step 3: Cython translates the <code class="docutils literal notranslate"><span class="pre">pyopenms/pyopenms.pyx</span></code> to C++ code at
<code class="docutils literal notranslate"><span class="pre">pyopenms/pyopenms.cpp</span></code></li>
<li>Step 4: A compiler compiles the C++ code to a Python module which is then
importable in Python with <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">pyopenms</span></code></li>
</ul>
<p>Maintaining existing wrappers: If the C++ API is changed, then pyOpenMS will
not build any more.  Thus, find the corresponding file in the <code class="docutils literal notranslate"><span class="pre">pyOpenMS/pxds/</span></code>
folder and adjust the function declaration accordingly.</p>
</div>
<div class="section" id="how-to-wrap-new-methods-in-existing-classes">
<h2>How to wrap new methods in existing classes<a class="headerlink" href="#how-to-wrap-new-methods-in-existing-classes" title="Permalink to this headline">¶</a></h2>
<p>Lets say you have written a new method for an existing OpenMS class and you
would like to expose this method to pyOpenMS. First, identify the correct
<code class="docutils literal notranslate"><span class="pre">.pxd</span></code> file in the <code class="docutils literal notranslate"><span class="pre">src/pyOpenMS/pxds</span></code> folder (for example for
<code class="docutils literal notranslate"><span class="pre">Adduct</span></code> that would be <a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/pxds/Adduct.pxd">Adduct.pxd</a>).
Open it and add your new function <em>with the correct indentation</em>:</p>
<ul>
<li><p class="first">Place the full function declaration into the file (indented as the other functions)</p>
</li>
<li><p class="first">Check whether you are using any classes that are not yet imported, if so add a corresponding <code class="docutils literal notranslate"><span class="pre">cimport</span></code> statement to the top of the file. E.g. if your method is using using <code class="docutils literal notranslate"><span class="pre">MSExperiment</span></code>, then add <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">MSExerpiment</span> <span class="pre">cimport</span> <span class="pre">*</span></code> to the top (note its cimport, not import).</p>
</li>
<li><p class="first">Remove any qualifiers (e.g. <cite>const</cite>) from the function signature and add <cite>nogil except +</cite> to the end of the signature</p>
<ul class="simple">
<li>Ex: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">setType(Int</span> <span class="pre">a);</span></code> becomes <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">setType(Int</span> <span class="pre">a)</span> <span class="pre">nogil</span> <span class="pre">except</span> <span class="pre">+</span></code></li>
<li>Ex: <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span> <span class="pre">getType()</span> <span class="pre">const;</span></code> becomes <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">getType()</span> <span class="pre">nogil</span> <span class="pre">except</span> <span class="pre">+</span></code></li>
</ul>
</li>
<li><p class="first">Remove any qualifiers (e.g. <cite>const</cite>) from the argument signatures, but leave reference and pointer indicators</p>
<blockquote>
<div><ul class="simple">
<li>Ex: <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> becomes <code class="docutils literal notranslate"><span class="pre">T</span></code>, preventing an additional copy operation</li>
<li>Ex: <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> will stay <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> (indicating <code class="docutils literal notranslate"><span class="pre">T</span></code> needs to copied back to Python)</li>
<li>Ex: <code class="docutils literal notranslate"><span class="pre">T*</span></code> will stay <code class="docutils literal notranslate"><span class="pre">T*</span></code> (indicating <code class="docutils literal notranslate"><span class="pre">T</span></code> needs to copied back to Python)</li>
<li>One exception is <code class="docutils literal notranslate"><span class="pre">OpenMS::String</span></code>, you can leave <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">String&amp;</span></code> as-is</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">STL constructs are replaced with Cython constructs: <code class="docutils literal notranslate"><span class="pre">std::vector&lt;X&gt;</span></code> becomes <code class="docutils literal notranslate"><span class="pre">libcpp_vector[</span> <span class="pre">X</span> <span class="pre">]</span></code> etc.</p>
</li>
<li><p class="first">Most complex STL constructs can be wrapped even if they are nested, however mixing them with user-defined types does not always work, see <a class="reference internal" href="#limitations">Limitations</a> below. Nested <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> constructs work well even with user-defined (OpenMS-defined) types. However, <code class="docutils literal notranslate"><span class="pre">std::map&lt;String,</span> <span class="pre">X&gt;</span></code> does not work (since <code class="docutils literal notranslate"><span class="pre">String</span></code> is user-defined, however a primitive C++ type such as <code class="docutils literal notranslate"><span class="pre">std::map&lt;std::string,</span> <span class="pre">X&gt;</span></code> would work).</p>
</li>
<li><p class="first">Python cannot pass primitive data types by reference (therefore no <code class="docutils literal notranslate"><span class="pre">int&amp;</span> <span class="pre">res1</span></code>)</p>
</li>
<li><p class="first">Replace <code class="docutils literal notranslate"><span class="pre">boost::shared_ptr&lt;X&gt;</span></code> with <code class="docutils literal notranslate"><span class="pre">shared_ptr[X]</span></code> and add <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">smart_ptr</span> <span class="pre">cimport</span> <span class="pre">shared_ptr</span></code> to the top</p>
</li>
<li><p class="first">Public members are simply added with  <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">member_name</span></code></p>
</li>
<li><p class="first">You can inject documentation that will be shown when calling <code class="docutils literal notranslate"><span class="pre">help()</span></code> in the function by adding <code class="docutils literal notranslate"><span class="pre">wrap-doc:Your</span> <span class="pre">documentation</span></code> as a comment after the function:</p>
<ul class="simple">
<li>Ex: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">modifyWidget()</span> <span class="pre">nogil</span> <span class="pre">except</span> <span class="pre">+</span> <span class="pre">#wrap-doc:This</span> <span class="pre">changes</span> <span class="pre">your</span> <span class="pre">widget</span></code></li>
</ul>
</li>
</ul>
<p>See the next section for a <a class="reference internal" href="#simpleexample">SimpleExample</a> and a more <a class="reference internal" href="#advancedexample">AdvancedExample</a> of a wrapped class with several functions.</p>
</div>
<div class="section" id="how-to-wrap-new-classes">
<h2>How to wrap new classes<a class="headerlink" href="#how-to-wrap-new-classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-simple-example">
<span id="simpleexample"></span><h3>A simple example<a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h3>
<p>To wrap a new OpenMS class: Create a new “.pxd” file in the folder <code class="docutils literal notranslate"><span class="pre">./pxds</span></code>. As
a small example, look at the <a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/pxds/Adduct.pxd">Adduct.pxd</a>
to get you started. Start with the following structure:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>from xxx cimport *
cdef extern from <span class="s2">&quot;&lt;OpenMS/path/to/header/Classname.h&gt;&quot;</span> namespace <span class="s2">&quot;OpenMS&quot;</span>:

    cdef cppclass ClassName<span class="o">(</span>DefaultParamHandler<span class="o">)</span>:
        <span class="c1"># wrap-inherits:</span>
        <span class="c1">#    DefaultParamHandler</span>

        ClassName<span class="o">()</span> nogil except +
        ClassName<span class="o">(</span>ClassName<span class="o">)</span> nogil except +

        Int getValue<span class="o">()</span> nogil except + <span class="c1">#wrap-doc:Gets value (between 0 and 5)</span>
        void setValue<span class="o">(</span>Int v<span class="o">)</span> nogil except + <span class="c1">#wrap-doc:Sets value (between 0 and 5)</span>
</pre></div>
</div>
<ul class="simple">
<li>make sure to use <code class="docutils literal notranslate"><span class="pre">ClassName:</span></code> instead of <code class="docutils literal notranslate"><span class="pre">ClassName(DefaultParamHandler):</span></code> to
wrap a class that does not inherit from another class and also remove the two
comments regarding inheritance below that line.</li>
<li>always use <code class="docutils literal notranslate"><span class="pre">cimport</span></code> and not Python <code class="docutils literal notranslate"><span class="pre">import</span></code></li>
<li>always add default constructor AND copy constructor to the code (note that the C++
compiler will add a default copy constructor to any class)</li>
<li>to expose a function to Python, copy the signature to your pxd file, e.g.
<code class="docutils literal notranslate"><span class="pre">DataValue</span> <span class="pre">getValue()</span></code> and make sure you <code class="docutils literal notranslate"><span class="pre">cimport</span></code> all corresponding classes.
Replace <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> with the corresponding Cython vector, in this case
<code class="docutils literal notranslate"><span class="pre">libcpp_vector</span></code> (see for example <a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/pxds/PepXMLFile.pxd">PepXMLFile.pxd</a>)</li>
<li>Remember to include a copy constructor (even if none was declared in the C++
header file) since Cython will need it for certain operations. Otherwise you
might see error messages like <code class="docutils literal notranslate"><span class="pre">item2.inst</span> <span class="pre">=</span> <span class="pre">shared_ptr[_ClassName](new</span> <span class="pre">_ClassName(deref(it_terms)))</span> <span class="pre">Call</span> <span class="pre">with</span> <span class="pre">wrong</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">arguments</span></code>.</li>
<li>you can add documentation that will show up in the interactive Python documentation (using <code class="docutils literal notranslate"><span class="pre">help()</span></code>) using the <code class="docutils literal notranslate"><span class="pre">wreap-doc</span></code> qualifier</li>
</ul>
</div>
<div class="section" id="a-further-example">
<span id="advancedexample"></span><h3>A further example<a class="headerlink" href="#a-further-example" title="Permalink to this headline">¶</a></h3>
<p>A slightly more complicated class could look like this, where we demonstrate
how to handle a templated class with template <code class="docutils literal notranslate"><span class="pre">T</span></code> and static methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xxx</span> <span class="nn">cimport</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">AbstractBaseClass</span> <span class="nn">cimport</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">AbstractBaseClassImpl1</span> <span class="nn">cimport</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">AbstractBaseClassImpl2</span> <span class="nn">cimport</span> <span class="o">*</span>
<span class="n">cdef</span> <span class="n">extern</span> <span class="kn">from</span> <span class="s2">&quot;&lt;OpenMS/path/to/header/Classname.h&gt;&quot;</span> <span class="n">namespace</span> <span class="s2">&quot;OpenMS&quot;</span><span class="p">:</span>

    <span class="n">cdef</span> <span class="n">cppclass</span> <span class="n">ClassName</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">DefaultParamHandler</span><span class="p">):</span>
        <span class="c1"># wrap-inherits:</span>
        <span class="c1">#    DefaultParamHandler</span>
        <span class="c1">#</span>
        <span class="c1"># wrap-instances:</span>
        <span class="c1">#   ClassName := ClassName[X]</span>
        <span class="c1">#   ClassNameY := ClassName[Y]</span>

        <span class="n">ClassName</span><span class="p">()</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>
        <span class="n">ClassName</span><span class="p">(</span><span class="n">ClassName</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-ignore</span>

        <span class="n">void</span> <span class="n">method_name</span><span class="p">(</span><span class="nb">int</span> <span class="n">param1</span><span class="p">,</span> <span class="n">double</span> <span class="n">param2</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>
        <span class="n">T</span> <span class="n">method_returns_template_param</span><span class="p">()</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>

        <span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>
        <span class="n">T</span> <span class="n">operator</span><span class="p">[](</span><span class="nb">int</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-upper-limit:size()</span>

        <span class="n">libcpp_vector</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>  <span class="c1"># wrap-iter-begin:__iter__(T)</span>
        <span class="n">libcpp_vector</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span>   <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>  <span class="c1"># wrap-iter-end:__iter__(T)</span>

        <span class="n">void</span> <span class="n">getWidgets</span><span class="p">(</span><span class="n">libcpp_vector</span><span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">keys</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>
        <span class="n">void</span> <span class="n">getWidgets</span><span class="p">(</span><span class="n">libcpp_vector</span><span class="p">[</span><span class="n">unsigned</span> <span class="nb">int</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">keys</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-as:getWAsInt</span>

        <span class="c1"># C++ signature: void process(AbstractBaseClass * widget)</span>
        <span class="n">void</span> <span class="n">process</span><span class="p">(</span><span class="n">AbstractBaseClassImpl1</span> <span class="o">*</span> <span class="n">widget</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>
        <span class="n">void</span> <span class="n">process</span><span class="p">(</span><span class="n">AbstractBaseClassImpl2</span> <span class="o">*</span> <span class="n">widget</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>

<span class="n">cdef</span> <span class="n">extern</span> <span class="kn">from</span> <span class="s2">&quot;&lt;OpenMS/path/to/header/Classname.h&gt;&quot;</span> <span class="n">namespace</span> <span class="s2">&quot;OpenMS::Classname&lt;OpenMS::X&gt;&quot;</span><span class="p">:</span>

    <span class="n">void</span> <span class="n">static_method_name</span><span class="p">(</span><span class="nb">int</span> <span class="n">param1</span><span class="p">,</span> <span class="n">double</span> <span class="n">param2</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-attach:ClassName</span>

<span class="n">cdef</span> <span class="n">extern</span> <span class="kn">from</span> <span class="s2">&quot;&lt;OpenMS/path/to/header/Classname.h&gt;&quot;</span> <span class="n">namespace</span> <span class="s2">&quot;OpenMS::Classname&lt;OpenMS::Y&gt;&quot;</span><span class="p">:</span>

    <span class="n">void</span> <span class="n">static_method_name</span><span class="p">(</span><span class="nb">int</span> <span class="n">param1</span><span class="p">,</span> <span class="n">double</span> <span class="n">param2</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-attach:ClassNameY</span>
</pre></div>
</div>
<p>Here the copy constructor will not be wrapped but the Cython parser will import
it from C++ so that is is present (using <code class="docutils literal notranslate"><span class="pre">wrap-ignore</span></code>). The <code class="docutils literal notranslate"><span class="pre">operator[]</span></code>
will return an object of type <code class="docutils literal notranslate"><span class="pre">X</span></code> or <code class="docutils literal notranslate"><span class="pre">Y</span></code> depending on the template
argument <code class="docutils literal notranslate"><span class="pre">T</span></code> and contain a guard that the number may not be exceed <code class="docutils literal notranslate"><span class="pre">size()</span></code>.</p>
<p>The wrapping of iterators allows for iteration over the objects inside the
<code class="docutils literal notranslate"><span class="pre">Classname</span></code> container using the appropriate Python function (here
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code> with the indicated return type <code class="docutils literal notranslate"><span class="pre">T</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">wrap-as</span></code> keyword allows the Python function to assume a different
name.</p>
<p>Note that pointers to abstract base classes can be passed as arguments but the
classes have to be known at compile time, e.g. the function <code class="docutils literal notranslate"><span class="pre">process</span></code>
takes a pointer to <code class="docutils literal notranslate"><span class="pre">AbstractBaseClass</span></code> which has two known
implementations <code class="docutils literal notranslate"><span class="pre">AbstractBaseClassImpl1</span></code> and
<code class="docutils literal notranslate"><span class="pre">AbstractBaseClassImpl2</span></code>. Then, the function needs to declared and
overloaded with both implementations as arguments as shown above.</p>
</div>
<div class="section" id="an-example-with-handwritten-addon-code">
<h3>An example with handwritten addon code<a class="headerlink" href="#an-example-with-handwritten-addon-code" title="Permalink to this headline">¶</a></h3>
<p>A more complex examples requires some hand-written wrapper code
(<code class="docutils literal notranslate"><span class="pre">pxds/Classname.pxd</span></code>), for example for singletons that implement a <code class="docutils literal notranslate"><span class="pre">getInstance()</span></code>
method that returns a pointer to the singleton resource. Note that in this case
it is quite important to not let autowrap take over the pointer and possibly
delete it when the lifetime of the Python object ends. This is done through
<code class="docutils literal notranslate"><span class="pre">wrap-manual-memory</span></code> and failing to doing so could lead to segmentation
faults in the program.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xxx</span> <span class="nn">cimport</span> <span class="o">*</span>
<span class="n">cdef</span> <span class="n">extern</span> <span class="kn">from</span> <span class="s2">&quot;&lt;OpenMS/path/to/header/Classname.h&gt;&quot;</span> <span class="n">namespace</span> <span class="s2">&quot;OpenMS&quot;</span><span class="p">:</span>

    <span class="n">cdef</span> <span class="n">cppclass</span> <span class="n">ModificationsDB</span> <span class="s2">&quot;OpenMS::ModificationsDB&quot;</span><span class="p">:</span>
        <span class="c1"># wrap-manual-memory</span>
        <span class="c1"># wrap-hash:</span>
        <span class="c1">#   getFullId().c_str()</span>

        <span class="n">ClassName</span><span class="p">(</span><span class="n">ClassName</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-ignore</span>

        <span class="n">void</span> <span class="n">method_name</span><span class="p">(</span><span class="nb">int</span> <span class="n">param1</span><span class="p">,</span> <span class="n">double</span> <span class="n">param2</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span>

        <span class="nb">int</span> <span class="n">process</span><span class="p">(</span><span class="n">libcpp_vector</span><span class="p">[</span><span class="n">Peak1D</span><span class="p">]</span><span class="o">.</span><span class="n">iterator</span><span class="p">,</span> <span class="n">libcpp_vector</span><span class="p">[</span><span class="n">Peak1D</span><span class="p">]</span><span class="o">.</span><span class="n">iterator</span><span class="p">)</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-ignore</span>

<span class="n">cdef</span> <span class="n">extern</span> <span class="kn">from</span> <span class="s2">&quot;&lt;OpenMS/path/to/header/Classname.h&gt;&quot;</span> <span class="n">namespace</span> <span class="s2">&quot;OpenMS::Classname&quot;</span><span class="p">:</span>

    <span class="n">const</span> <span class="n">ClassName</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> <span class="n">nogil</span> <span class="k">except</span> <span class="o">+</span> <span class="c1"># wrap-ignore</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">wrap-manual-memory</span></code> keyword indicates that memory management
will be handled manually and autowrap can assume that a member called
<code class="docutils literal notranslate"><span class="pre">inst</span></code> will be provided which implements a <code class="docutils literal notranslate"><span class="pre">gets()</span></code> method to
obtain a pointer to an object of C++ type <code class="docutils literal notranslate"><span class="pre">Classname</span></code>.</p>
<p>We then have to provide such an object (<code class="docutils literal notranslate"><span class="pre">addons/Classname.pyx</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This will go into the header (no empty lines below is *required*)</span>
<span class="c1"># NOTE: _Classname is the C++ class while Classname is the Python class</span>
<span class="kn">from</span> <span class="nn">Classname</span> <span class="nn">cimport</span> <span class="nn">Classname</span> <span class="nn">as</span> <span class="nn">_Classname</span>
<span class="n">cdef</span> <span class="k">class</span> <span class="nc">ClassnameWrapper</span><span class="p">:</span>
    <span class="c1"># A small utility class holding a ptr and implementing get()</span>
    <span class="n">cdef</span> <span class="n">const</span> <span class="n">_Classname</span><span class="o">*</span> <span class="n">wrapped</span>
    <span class="n">cdef</span> <span class="n">setptr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">const</span> <span class="n">_Classname</span><span class="o">*</span> <span class="n">wrapped</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">wrapped</span>
    <span class="n">cdef</span> <span class="n">const</span> <span class="n">_Classname</span><span class="o">*</span> <span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">except</span> <span class="o">*</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span>

    <span class="c1"># This will go into the class (after the first empty line)</span>
    <span class="c1"># NOTE: we use 4 spaces indent</span>
    <span class="c1"># NOTE: using shared_ptr for a singleton will lead to segfaults, use raw ptr instead</span>
    <span class="n">cdef</span> <span class="n">ClassnameWrapper</span> <span class="n">inst</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">inst</span> <span class="o">=</span> <span class="n">ClassnameWrapper</span><span class="p">()</span>
      <span class="c1"># the following require some knowledge of the internals of autowrap:</span>
      <span class="c1"># we call the getInstance method to obtain raw ptr</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">inst</span><span class="o">.</span><span class="n">setptr</span><span class="p">(</span><span class="n">_getInstance_Classname</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__dealloc__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c1"># Careful here, the wrapped ptr is a single instance and we should not</span>
      <span class="c1"># reset it (which is why we used &#39;wrap-manual-dealloc&#39;)</span>
      <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Container</span> <span class="n">c</span><span class="p">):</span>
      <span class="c1"># An example function here (processing Container c):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inst</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">inst</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">inst</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
</pre></div>
</div>
<p>Note how the manual wrapping of the process functions allows us to
access the <code class="docutils literal notranslate"><span class="pre">inst</span></code> pointer of the argument as well as of the object
itself, allowing us to call C++ functions on both pointers. This makes it easy
to generate the required iterators and process the container efficiently.</p>
</div>
<div class="section" id="considerations-and-limitations">
<span id="limitations"></span><h3>Considerations and limitations<a class="headerlink" href="#considerations-and-limitations" title="Permalink to this headline">¶</a></h3>
<p>Further considerations and limitations:</p>
<ul class="simple">
<li>Inheritance: there are some limitations, see for example <code class="docutils literal notranslate"><span class="pre">Precursor.pxd</span></code></li>
<li>Reference: arguments by reference may be copied under some circumstances. For
example, if they are in an array then not the original argument is handed
back, so comparisons might fail. Also, simple Python types like int, float
etc cannot be passed by reference.</li>
<li>operator+=: see for example <code class="docutils literal notranslate"><span class="pre">AASequence.iadd</span></code> in <code class="docutils literal notranslate"><span class="pre">AASequence.pxd</span></code></li>
<li>operator==, !=, &lt;=, &lt;, &gt;=, &gt; are wrapped automatically</li>
<li>Iterators: some limitations apply, see MSExperiment.pxd for an example</li>
<li>copy-constructor becomes __copy__ in Python</li>
<li>shared pointers: is handled automatically, check DataAccessHelper using <code class="docutils literal notranslate"><span class="pre">shared_ptr[Spectrum]</span></code>. Use <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">smart_ptr</span> <span class="pre">cimport</span> <span class="pre">shared_ptr</span></code> as import statement</li>
</ul>
<p>These hints can be given to autowrap classes (also check the autowrap documentation):</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">wrap-ignore</span></code> is a hint for autowrap to not wrap the class (but the declaration might still be important for Cython to know about)</li>
<li><code class="docutils literal notranslate"><span class="pre">wrap-instances:</span></code> for templated classes (see MSSpectrum.pxd)</li>
<li><code class="docutils literal notranslate"><span class="pre">wrap-hash:</span></code> hash function to use for <code class="docutils literal notranslate"><span class="pre">__hash__</span></code> (see Residue.pxd)</li>
<li><code class="docutils literal notranslate"><span class="pre">wrap-manual-memory:</span></code> hint that memory management will be done manually</li>
</ul>
<p>These hints can be given to autowrap functions (also check the autowrap documentation):</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">wrap-ignore</span></code> is a hint for autowrap to not wrap the function (but the declaration might still be important for Cython to know about)</li>
<li><code class="docutils literal notranslate"><span class="pre">wrap-as:</span></code> see for example AASequence</li>
<li><code class="docutils literal notranslate"><span class="pre">wrap-iter-begin:</span></code>, <code class="docutils literal notranslate"><span class="pre">wrap-iter-end:</span></code> (see ConsensusMap.pxd)</li>
<li><code class="docutils literal notranslate"><span class="pre">wrap-attach:</span></code> enums, static methods (see for example VersionInfo.pxd)</li>
<li><code class="docutils literal notranslate"><span class="pre">wrap-upper-limit:size()</span></code> (see MSSpectrum.pxd)</li>
</ul>
</div>
<div class="section" id="wrapping-code-yourself-in-addons">
<h3>Wrapping code yourself in ./addons<a class="headerlink" href="#wrapping-code-yourself-in-addons" title="Permalink to this headline">¶</a></h3>
<p>Not all code can be wrapped automatically (yet). Place a file with the same (!)
name in the addons folder (e.g. <code class="docutils literal notranslate"><span class="pre">myClass.pxd</span></code> in <code class="docutils literal notranslate"><span class="pre">pxds/</span></code> and <code class="docutils literal notranslate"><span class="pre">myClass.pyx</span></code> in <code class="docutils literal notranslate"><span class="pre">addons/</span></code>)
and leave two lines empty on the top (this is important). Start with 4 spaces
of indent and write your additional wrapper functions, adding a wrap-ignore
comment to the pxd file. See the example above, some additional examples, look into the <code class="docutils literal notranslate"><span class="pre">src/pyOpenMS/addons/</span></code> folder:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/addons/IDRipper.pyx">IDRipper.pyx</a><ul>
<li>for an example of both input and output of a complex STL construct (<code class="docutils literal notranslate"><span class="pre">map&lt;</span> <span class="pre">String,</span> <span class="pre">pair&lt;vector&lt;&gt;,</span> <span class="pre">vector&lt;&gt;</span> <span class="pre">&gt;</span></code> )</li>
</ul>
</li>
<li><a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/addons/MSQuantifications.pyx">MSQuantifications.pyx</a><ul>
<li>for a <code class="docutils literal notranslate"><span class="pre">vector&lt;</span> <span class="pre">vector&lt;</span> <span class="pre">pair</span> <span class="pre">&lt;String,double</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code> as input in registerExperiment</li>
<li>for a <code class="docutils literal notranslate"><span class="pre">map&lt;</span> <span class="pre">String,</span> <span class="pre">Ratio&gt;</span></code> in getRatios to get returned</li>
</ul>
</li>
<li><a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/addons/QcMLFile.pyx">QcMLFile.pyx</a>
- for a <code class="docutils literal notranslate"><span class="pre">map&lt;</span> <span class="pre">String,</span> <span class="pre">map&lt;</span> <span class="pre">String,String&gt;</span> <span class="pre">&gt;</span></code> as input</li>
<li><a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/addons/SequestInfile.pyx">SequestInfile.pyx</a><ul>
<li>for a <code class="docutils literal notranslate"><span class="pre">map&lt;</span> <span class="pre">String,</span> <span class="pre">vector&lt;String&gt;</span> <span class="pre">&gt;</span></code> to get returned</li>
</ul>
</li>
<li><a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/addons/Attachment.pyx">Attachment.pyx</a><ul>
<li>for a <code class="docutils literal notranslate"><span class="pre">vector&lt;</span> <span class="pre">vector&lt;String&gt;</span> <span class="pre">&gt;</span></code> to get returned</li>
</ul>
</li>
<li><a class="reference external" href="https://github.com/OpenMS/OpenMS/blob/develop/src/pyOpenMS/pxds/ChromatogramExtractorAlgorithm.pxd">ChromatogramExtractorAlgorithm.pxd</a><ul>
<li>for an example of an abstract base class (<code class="docutils literal notranslate"><span class="pre">ISpectrumAccess</span></code>) in the function
<code class="docutils literal notranslate"><span class="pre">extractChromatograms</span></code> - this is solved by copy-pasting the function
multiple times for each possible implementation of the abstract base class.</li>
</ul>
</li>
</ul>
<p>Make sure that you <em>always</em> declare your objects (all C++ and all Cython
objects need to be declared) using <code class="docutils literal notranslate"><span class="pre">cdef</span></code> Type name. Otherwise you get <code class="docutils literal notranslate"><span class="pre">Cannot</span>
<span class="pre">convert</span> <span class="pre">...</span> <span class="pre">to</span> <span class="pre">Python</span> <span class="pre">object</span></code> errors.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="build_from_source.html" class="btn btn-neutral float-left" title="Build from source" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, OpenMS Team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>